/**
 * Excel Export Utilities
 * Handles conversion of data to Excel format using exceljs library
 */

import * as ExcelJS from 'exceljs';

export interface ExcelExportOptions {
  filename?: string;
  sheetName?: string;
  includeHeaders?: boolean;
  dateFormat?: string;
}

export class ExcelExporter {
  /**
   * Convert an array of objects to Excel format
   */
  static async arrayToExcel<T extends Record<string, any>>(
    data: T[],
    options: ExcelExportOptions = {}
  ): Promise<Buffer> {
    const {
      sheetName = 'Sheet1',
      includeHeaders = true,
      dateFormat = 'yyyy-mm-dd'
    } = options;

    const workbook = new ExcelJS.Workbook();
    const worksheet = workbook.addWorksheet(sheetName);

    if (data.length === 0) {
      // Create empty worksheet
      worksheet.addRow(['No data available']);
      const buffer = await workbook.xlsx.writeBuffer();
      return Buffer.from(buffer);
    }

    // Add headers if requested
    if (includeHeaders && data.length > 0) {
      const headers = Object.keys(data[0]);
      worksheet.addRow(headers);
      
      // Style headers
      const headerRow = worksheet.getRow(1);
      headerRow.font = { bold: true };
      headerRow.fill = {
        type: 'pattern',
        pattern: 'solid',
        fgColor: { argb: 'FFE0E0E0' }
      };
    }

    // Add data rows
    data.forEach(row => {
      const values = Object.values(row);
      worksheet.addRow(values);
    });

    // Auto-fit columns
    worksheet.columns.forEach(column => {
      column.width = 15;
    });

    // Generate Excel buffer
    const buffer = await workbook.xlsx.writeBuffer();
    return Buffer.from(buffer);
  }

  /**
   * Convert analytics data to Excel format with multiple sheets
   */
  static async analyticsToExcel(analyticsData: any): Promise<Buffer> {
    const workbook = new ExcelJS.Workbook();

    // Add metadata sheet
    const metadataWs = workbook.addWorksheet('Metadata');
    metadataWs.addRow(['Analytics Export']);
    metadataWs.addRow(['Exported At', analyticsData.exportedAt]);
    metadataWs.addRow(['Company ID', analyticsData.companyId]);
    metadataWs.addRow(['']);
    metadataWs.addRow(['Generated by Benefits AI Chatbot']);
    metadataWs.addRow(['Export Date', new Date().toISOString()]);

    // Add chat analytics sheet
    if (analyticsData.analytics?.chat) {
      const chatWs = workbook.addWorksheet('Chat Analytics');
      const chatData = this.prepareChatAnalyticsForExcel(analyticsData.analytics.chat);
      chatWs.addRow(['Metric', 'Value']);
      chatData.forEach(row => {
        chatWs.addRow([row.Metric, row.Value]);
      });
    }

    // Add company analytics sheet
    if (analyticsData.analytics?.company) {
      const companyWs = workbook.addWorksheet('Company Analytics');
      const companyData = this.prepareCompanyAnalyticsForExcel(analyticsData.analytics.company);
      companyWs.addRow(['Metric', 'Value']);
      companyData.forEach(row => {
        companyWs.addRow([row.Metric, row.Value]);
      });
    }

    // Add user activity sheet
    if (analyticsData.analytics?.users && analyticsData.analytics.users.length > 0) {
      const userWs = workbook.addWorksheet('User Activity');
      const userData = this.prepareUserActivityForExcel(analyticsData.analytics.users);
      if (userData.length > 0) {
        userWs.addRow(Object.keys(userData[0]));
        userData.forEach(row => {
          userWs.addRow(Object.values(row));
        });
      }
    }

    // Add system metrics sheet
    if (analyticsData.analytics?.systemMetrics) {
      const systemWs = workbook.addWorksheet('System Metrics');
      const systemData = this.prepareSystemMetricsForExcel(analyticsData.analytics.systemMetrics);
      systemWs.addRow(['Metric', 'Value']);
      systemData.forEach(row => {
        systemWs.addRow([row.Metric, row.Value]);
      });
    }

    const buffer = await workbook.xlsx.writeBuffer();
    return Buffer.from(buffer);
  }

  /**
   * Convert chat messages to Excel format
   */
  static async chatMessagesToExcel(messages: any[]): Promise<Buffer> {
    const data = messages.map((message, index) => ({
      'Message #': index + 1,
      'Timestamp': message.timestamp || message.createdAt,
      'User ID': message.userId,
      'Message Type': message.type || 'user',
      'Content': message.content,
      'Tokens Used': message.tokensUsed || 0,
      'Response Time (ms)': message.responseTime || 0
    }));

    return this.arrayToExcel(data, {
      sheetName: 'Chat Messages',
      filename: 'chat-messages.xlsx'
    });
  }

  /**
   * Convert user activity to Excel format
   */
  static async userActivityToExcel(users: any[]): Promise<Buffer> {
    const data = users.map(user => ({
      'User ID': user.id,
      'Email': user.email,
      'Display Name': user.displayName,
      'Role': user.role,
      'Last Active': user.lastActive,
      'Total Chats': user.totalChats || 0,
      'Total Messages': user.totalMessages || 0,
      'Status': user.status || 'active',
      'Created At': user.createdAt,
      'Company ID': user.companyId
    }));

    return this.arrayToExcel(data, {
      sheetName: 'User Activity',
      filename: 'user-activity.xlsx'
    });
  }

  /**
   * Create a downloadable Excel file
   */
  static createDownloadableExcel(
    excelBuffer: Buffer,
    filename: string = 'export.xlsx'
  ): { content: Buffer; headers: Record<string, string> } {
    return {
      content: excelBuffer,
      headers: {
        'Content-Type': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        'Content-Disposition': `attachment; filename="${filename}"`,
        'Cache-Control': 'no-cache, no-store, must-revalidate',
        'Pragma': 'no-cache',
        'Expires': '0',
        'Content-Length': excelBuffer.length.toString()
      }
    };
  }

  // Helper methods for preparing data for Excel
  private static prepareChatAnalyticsForExcel(chatData: any): any[] {
    const data = [
      { 'Metric': 'Total Chats', 'Value': chatData.totalChats || 0 },
      { 'Metric': 'Average Messages per Chat', 'Value': chatData.averageMessagesPerChat || 0 },
      { 'Metric': 'Total Questions', 'Value': chatData.totalQuestions || 0 },
      { 'Metric': 'Average Response Time (ms)', 'Value': chatData.averageResponseTime || 0 },
      { 'Metric': 'Satisfaction Rate (%)', 'Value': (chatData.satisfactionRate || 0) * 100 },
      { 'Metric': 'Total Tokens Used', 'Value': chatData.totalTokensUsed || 0 },
      { 'Metric': 'Cost per Chat', 'Value': chatData.costPerChat || 0 }
    ];

    // Add top questions
    if (chatData.topQuestions && chatData.topQuestions.length > 0) {
      data.push({ 'Metric': '', 'Value': '' }); // Empty row
      data.push({ 'Metric': 'Top Questions', 'Value': '' });
      chatData.topQuestions.forEach((q: any, index: number) => {
        data.push({
          'Metric': `Question ${index + 1}`,
          'Value': q.question || q
        });
      });
    }

    return data;
  }

  private static prepareCompanyAnalyticsForExcel(companyData: any): any[] {
    return [
      { 'Metric': 'Total Users', 'Value': companyData.totalUsers || 0 },
      { 'Metric': 'Active Users', 'Value': companyData.activeUsers || 0 },
      { 'Metric': 'Total Documents', 'Value': companyData.totalDocuments || 0 },
      { 'Metric': 'Storage Used (MB)', 'Value': companyData.storageUsed || 0 },
      { 'Metric': 'Average Response Time (ms)', 'Value': companyData.averageResponseTime || 0 },
      { 'Metric': 'Satisfaction Rate (%)', 'Value': (companyData.satisfactionRate || 0) * 100 }
    ];
  }

  private static prepareUserActivityForExcel(users: any[]): any[] {
    return users.map(user => ({
      'User ID': user.id,
      'Email': user.email,
      'Display Name': user.displayName,
      'Role': user.role,
      'Last Active': user.lastActive,
      'Total Chats': user.totalChats || 0,
      'Total Messages': user.totalMessages || 0,
      'Status': user.status || 'active',
      'Created At': user.createdAt,
      'Company ID': user.companyId
    }));
  }

  private static prepareSystemMetricsForExcel(systemMetrics: any): any[] {
    return [
      { 'Metric': 'CPU Usage (%)', 'Value': systemMetrics.cpuUsage || 0 },
      { 'Metric': 'Memory Usage (%)', 'Value': systemMetrics.memoryUsage || 0 },
      { 'Metric': 'Disk Usage (%)', 'Value': systemMetrics.diskUsage || 0 },
      { 'Metric': 'Network Latency (ms)', 'Value': systemMetrics.networkLatency || 0 },
      { 'Metric': 'Error Rate (%)', 'Value': systemMetrics.errorRate || 0 },
      { 'Metric': 'Uptime (seconds)', 'Value': systemMetrics.uptime || 0 }
    ];
  }
}
